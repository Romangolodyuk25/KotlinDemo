package `Изучение с 0`

import Исключение.ValidationException

fun main(args:Array<String>){
    val a = 10
    var b = 0
    var tel = 12345667
// блок называется try-catch
    try {
        println(a/b) // потенциально опасный кусок кода который приведет к EXCEPTION, ЕСЛИ он произойдет сработает блок catch
    } catch (e:ArithmeticException) {//пишется сразу после try для ПЕРЕХВАТА (ОТЛОВА ИСКЛЮЧЕНИЯ) (e:ArithmeticException) - то что мы отлавливаем
        println("Попытка деления на 0") // строка распечатается в случае если был EXCEPTION
    }catch (e:Exception) {//если мы не знаем какой EXCEPTION мы отлавливаем можно просто написать e:Exception(Отлавливает все)
        e.printStackTrace()//распечатает порядок вызовов в стеке
        //println("Произошла ошибка")
    } finally { // Произойдет в любом случае был отлевлен EXCEPTION или НЕ БЫЛ
        println("Вызвался finally")
    }
    //throw CharacterCodingException() Вызываем Исключение ВРУЧНУЮ

    try {//вызвал функциб validation с параметром tel(Номер тел)
        validate(tel)
    } catch (e:ValidationException) {//присвоил e: - Свое исключение которое проверяется в функции validation
        println(e.message)
    }
}
fun validate(tel:Int) {
if (tel<100000000) {
    throw ValidationException("Произошла ошибка при вводе телефона")
}
}
/*
    Есть ИСКЛЮЧЕНИЯ(Exception) и есть ОШИБКИ (Error) Они обя являются наследниками супер класа Throwable(Троубл)
    Exception отличается от ERROR тем что во время исключениея мы можем среагировать на него в ходе работы и изменить код
    в случае с ERROR мы никак не можем срегаировать на него и выполнение программы не возможно(Переполняется стек ОВЕРФЛОУ),
    нужно переписать код
    throw - бросить
    1)try{} - попробовать
    2)catch(){} - поймать
    3) finally {} - завершаюий - блок вызовется ВНЕ ЗАВИСИМОСТИ НЕ БЫЛО Exetion или БЫЛО
    4) trow - бросить - нужно что бы явно сгенирировать исключение самому

    1.try {}- cлово с которого начинается отлов исключений(Перехватить исключение (EXCEPTION) что бы сказать компиляторуБ
    что если у нас будет исключение , то просто не делай его)
    2. catch() {} идет сразу после try, в круглых скобках нужно указать какое именно ИСКЛЮЧЕНИЕ мы хотим ОТЛОВИТЬ
    нужно дать имя "е:" который будет проброшен с ТИПОМ EXCEPTION который моджет произойти
    3. finally {} идет после catch и он вызвается в ЛЮБОВ СЛУЧАЕ - ВНЕ ЗАВИСИМОСТИ от того был ли отловлен EXCEPTION или не был
    нужен для того что бы выполнить ЗАВЕРШАЮЩИЕ операции
    4. e: У exception есть такая штукак как СТЕКТРЕЙСЕН (SteckTrace) вызывается она так e.printStackTrace() нужно будет что бы понять
    каким путем было распечатано ИСКЛЮЧЕНИЕ
    5. throw нужно для того что бы самому саостоятельно вызвать Исключение, нужно для того что бы САМОСТОЯТЕЛЬНО можно было
    создать какое-то исключение
     */